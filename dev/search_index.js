var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Enlsip]","category":"page"},{"location":"reference/#Enlsip.AbstractCnlsModel","page":"Reference","title":"Enlsip.AbstractCnlsModel","text":"AbstractCnlsModel\n\nAbstract type for CnlsModel structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Enlsip.CnlsModel","page":"Reference","title":"Enlsip.CnlsModel","text":"model = CnlsModel(residuals, nb_parameters, nb_residuals)\n\nConstructor for CnlsModel.\n\nPositional arguments\nresiduals : function that computes the vector of residuals\nnb_parameters : number of variables\nnb_residuals : number of residuals\nKeywords arguments :\nstating_point : initial solution (default is a vector of zeros of appropriate dimension)\njacobian_residuals : function that computes the jacobian matrix of the residuals. If not passed as argument, it is computed numericcaly by forward differences\neq_constraints : function that computes the vector of equality constraints\njacobian_eqcons : function that computes the jacobian matrix of the equality constraints. If not passed as argument, it is computed numericcaly by forward differences\nnb_eqcons : number of equality constraints\nineq_constraints : function that computes the vector of inequality constraints\njacobian_ineqcons : function that computes the jacobian matrix of the inequality constraints. If not passed as argument, it is computed numericcaly by forward differences\nnb_ineqcons : number of inequality constraints\nx_low and x_upp : respectively vectors of lower and upper bounds\n\n\n\n\n\n","category":"type"},{"location":"reference/#Enlsip.CnlsModel-2","page":"Reference","title":"Enlsip.CnlsModel","text":"CnlsModel\n\nStructure modeling an instance of a constrainted nonlinear least squares problem.\n\nThis structure contains the following attributes:\n\n* `residuals` : function that computes the vector of residuals\n\n* `nb_parameters` : number of variables\n\n* `nb_residuals` : number of residuals\n\n* `stating_point` : initial solution\n\n* `jacobian_residuals` : function that computes the jacobian matrix of the residuals\n\n* `eq_constraints` : function that computes the vector of equality constraints\n\n* `jacobian_eqcons` : function that computes the jacobian matrix of the equality constraints\n\n* `nb_eqcons` : number of equality constraints\n\n* `ineq_constraints` : function that computes the vector of inequality constraints\n\n* `jacobian_ineqcons` : function that computes the jacobian matrix of the inequality constraints\n\n* `nb_ineqcons` : number of inequality constraints\n\n* `x_low` and `x_upp` : respectively vectors of lower and upper bounds\n\n* `status_code` : integer indicating the solving status of the model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Enlsip.objective_value-Tuple{CnlsModel}","page":"Reference","title":"Enlsip.objective_value","text":"objective_value(model)\n\nOnce the given model has been solved, returns the value of the objective function, i.e. sum of squared residuals functions, computed at the optimal solution. If no convergence, this value is computed at the last solution obtained.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Enlsip.solution-Tuple{CnlsModel}","page":"Reference","title":"Enlsip.solution","text":"solution(model)\n\nOnce the given model has been solved, this function returns the optimal solution, or last solution obtained if no convergence, as a Vector of approriate dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Enlsip.solve!-Tuple{CnlsModel}","page":"Reference","title":"Enlsip.solve!","text":"solve!(model)\n\nOnce a CnlsModel has been instantiated, this function solves the optimzation problem associated by using the method implemented in the Enlsip solver.\n\nThe following optionnal arguments can be provided:\n\nsilent::Bool \nSet to false if one wants the algorithm to print details about the iterations and termination of the solver\nDefault value is set to false\nmax_iter::Int \nMaximum number of iterations allowed\nDefault value is set to 100\nscaling::Bool \nSet to true if one wants the algorithm to work with a constraints jacobian matrix whose rows are scaled (i.e. all constraints gradients vectors are scaled)\nDefault value is set to false\n\n\n\n\n\n","category":"method"},{"location":"reference/#Enlsip.status-Tuple{CnlsModel}","page":"Reference","title":"Enlsip.status","text":"status(model)\n\nReturns readable information on the solving status of model. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Enlsip.total_nb_constraints-Tuple{CnlsModel}","page":"Reference","title":"Enlsip.total_nb_constraints","text":"total_nb_constraints(model)\n\nReturns the total number of constraints, i.e. equalities, inequalities and bounds, of the given model.\n\nSee also: CnlsModel.\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Enlsip.jl documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package Enlsip.jl is the Julia version of an eponymous Fortran77 library (ENLSIP standing for Easy Nonlinear Least Squares Inequalities Program) designed to solve nonlinear least squares problems under nonlinear constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The optimization method implemented in Enlsip was conceived in the late 1980s by two swedish authors named Per Lindström and Per Åke Wedin [1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problems that can be solved using Enlsip are modeled as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nmin quad   dfrac12 r(x)^2 \ntextst quad  c_i(x) = 0 quad i =1ldotsq \n c_j(x) geq 0 quad j=q+1ldotsell \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where rmathbbR^nrightarrowmathbbR^m, the residuals, and cmathbbR^nrightarrowmathbbR^q+ell, concatenation of the constraints, are mathcalC^1 multi-functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that box constraints are modeled as general inequality constraints.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To add Enlsip, use Julia's package manager by typing the following command inside the REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Enlsip\")","category":"page"},{"location":"#How-to-use","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Enlsip.jl to solve optimization problems consists in, first, instantiating a model and then call the solver on it. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details and examples with problems from the litterature in the Usage page.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: P. Lindström and P.Å. Wedin, Gauss-Newton based algorithms for constrained nonlinear least squares problems, Institute of Information processing, University of Umeå Sweden, 1988.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"CurrentModule = Enlsip","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"using Enlsip","category":"page"},{"location":"tutorial/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"This sections provides details on how to instantiate and solve a constrained least squares problem with Enlsip.jl As a reminder from Home, problems to solve are of the following form:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"beginaligned\nundersetxmin quad   dfrac12 r(x)^2 \ntextst quad  c_i(x) = 0 quad i =1ldotsq \n c_j(x) geq 0 quad j=q+1ldotsell \nendaligned","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Note that with this formulation, bounds constraints are not distinguished from general inequality constraints. Though, as shown later in this section, they can be provided as vectors of lower and/or upper bounds, which is more convenient for this type of constraints.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Also, the Enlsip solver works with double precision float numbers (i.e. type Float64).","category":"page"},{"location":"tutorial/#Instantiate-a-model","page":"Usage","title":"Instantiate a model","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Solving a problem with Enlsip is organized in two steps.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"First, a model of type CnlsModel must be instantiated. ","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"The CnlsModel constructor requires the evaluation functions of residuals, constraints, their associated jacobian matrices and dimensions of the problem. ","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Although the package enables one to create linear unconstrained least squares, it is recommended to use it to solve nonlinear least squares with general constraints.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"The three following positional arguments are mandatory to create a model:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"residuals : function that computes the vector of residuals\nnb_parameters : number of variables\nnb_residuals : number of residuals","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"The following keywords arguments are optionnal and deal with constraints and jacobian matrices computations. If the jacobian matrices functions are not provided, they are computed numerically by forward differences within Enlsip.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Argument Details\nstarting_point initial solution (can be an infeasbile point)\njacobian_residuals function computing the jacobian matrix of the residuals\neq_constraints function computing the equality constraints\njacobian_eqcons function computing the jacobian matrix of the equality constraints\nnb_eqcons number of equality constraints\nineq_constraints function computing the inequality constraints\njacobian_ineqcons function computing the jacobian matrix of the inequality constraints\nnb_ineqcons number of inequality constraints\nx_low vector of lower bounds\nx_upp vector of upper bounds","category":"page"},{"location":"tutorial/#Solving-a-model","page":"Usage","title":"Solving a model","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Then, the Enlsip solver can be used by calling the solve! function on a instantiated model.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.solve!","category":"page"},{"location":"tutorial/#Enlsip.solve!","page":"Usage","title":"Enlsip.solve!","text":"solve!(model)\n\nOnce a CnlsModel has been instantiated, this function solves the optimzation problem associated by using the method implemented in the Enlsip solver.\n\nThe following optionnal arguments can be provided:\n\nsilent::Bool \nSet to false if one wants the algorithm to print details about the iterations and termination of the solver\nDefault value is set to false\nmax_iter::Int \nMaximum number of iterations allowed\nDefault value is set to 100\nscaling::Bool \nSet to true if one wants the algorithm to work with a constraints jacobian matrix whose rows are scaled (i.e. all constraints gradients vectors are scaled)\nDefault value is set to false\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"By default, the algorithm will print some details about the iterations performed through during execution.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Here are some details on how to read and understand the different columns of the output:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Column Details\niter iteration number\nobjective value of the sum of squared residuals (i.e. objective function) at current point\nvertvert active_constraints vertvert^2 value of the sum of squared active constraints at current point\nvertvert p vertvert norm of the search direction computed at current iteration\nalpha value of the steplength computed at current iteration\nreduction reduction in the objective function performed at curret iteration","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Once the Enlsip solver has been called, one can get additional info about the success, or failure, of the algorithm by calling one of the following functions:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Function\nsolution\nstatus\nobjective_value","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.solution","category":"page"},{"location":"tutorial/#Enlsip.solution","page":"Usage","title":"Enlsip.solution","text":"solution(model)\n\nOnce the given model has been solved, this function returns the optimal solution, or last solution obtained if no convergence, as a Vector of approriate dimension.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.status","category":"page"},{"location":"tutorial/#Enlsip.status","page":"Usage","title":"Enlsip.status","text":"status(model)\n\nReturns readable information on the solving status of model. \n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.objective_value","category":"page"},{"location":"tutorial/#Enlsip.objective_value","page":"Usage","title":"Enlsip.objective_value","text":"objective_value(model)\n\nOnce the given model has been solved, returns the value of the objective function, i.e. sum of squared residuals functions, computed at the optimal solution. If no convergence, this value is computed at the last solution obtained.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Examples","page":"Usage","title":"Examples","text":"","category":"section"},{"location":"tutorial/#Problem-65-from-Hock-and-Schittkowski-collection[1]","page":"Usage","title":"Problem 65 from Hock and Schittkowski collection[1]","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"We show how to implement and solve the following problem:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"beginaligned\nmin quad  (x_1-x_2)^2 + dfrac(x_1+x_2-10)^29+(x_3-5)^2  \ntextst quad  48-x_1^2-x_2^2-x_3^2 geq 0\n -45leq x_i leq 45 quad i=12\n -5 leq x_3  leq 5\nendaligned","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"First, we provide the dimensions of the problems.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Dimensions of the problem\n\nn = 3 # number of parameters\nm = 3 # number of residuals\nnb_eq = 0 # number of equality constraints\nnb_constraints = 7 # number of inequality constraints\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Then, we define the functions required to compute the residuals, constraints, their respective jacobian matrices and a starting point.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Residuals and jacobian matrix associated\nr(x::Vector) = [x[1] - x[2]; (x[1]+x[2]-10.0) / 3.0; x[3]-5.0]\n\njac_r(x::Vector) = [1. -1. 0;\n    1/3 1/3 0.;\n    0. 0. 1.]\n\n# Constraints (one equality and box constraints)\n\nc(x::Vector) = [48.0 - x[1]^2-x[2]^2-x[3]^2] # evaluation function for the equality constraint\njac_c(x::Vector) = [ -2x[1] -2x[2] -2x[3]] # jacobian matrix of the equality constraint\n\nx_l = [-4.5, -4.5, -5.0] # lower bounds\nx_u = [4.5, 4.5, 5.0] # upper bounds\n\n# Starting point \nx0 = [-5.0, 5.0, 0.0]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"A CnlsModel can now be instantiated.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Instantiate a model associated with the problem \nhs65_model = Enlsip.CnlsModel(r, n, m ;starting_point=x0, ineq_constraints = c, \nnb_ineqcons = 1, x_low=x_l, x_upp=x_u, jacobian_residuals=jac_r, jacobian_ineqcons=jac_c)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Finally, the solve! function can be called on our model. In this example, we set the silent optionnal argument to true so no output will be printed. See previous Solving a model section for details about what is printed after solving a problem. Other optionnal arguments remain to default values.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.solve!(hs65_model, silent=true)","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Once Enlsip solver has been executed on a problem, one can check if the problem has been successfully solved or not.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Enlsip.status(hs65_model)","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"One can also get the optimal solution obtained and value of objective function at that point.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"hs65_solution = Enlsip.solution(hs65_model)","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"hs65_objective = Enlsip.objective_value(hs65_model)","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"[1]: W. Hock and K. Schittkowski. Test Examples for Nonlinear Programming Codes, volume 187 of Lecture Notes in Economics and Mathematical Systems. Springer, second edition, 1980.","category":"page"}]
}
