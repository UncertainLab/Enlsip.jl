var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Enlsip]","category":"page"},{"location":"api/#Enlsip.AbstractCnlsModel","page":"API","title":"Enlsip.AbstractCnlsModel","text":"AbstractCnlsModel\n\nAbstract type for CnlsModel structure.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enlsip.CnlsModel","page":"API","title":"Enlsip.CnlsModel","text":"model = CnlsModel(residuals, nb_parameters, nb_residuals)\n\nConstructor for CnlsModel\n\nThe following arguments are mandatory to instantiate a model:\n\n* `residuals` : function that computes the vector of residuals\n\n* `nb_parameters` : number of variables\n\n* `nb_residuals` : number of residuals\n\nThe following can be provided as optionnal arguments:\n\n* `stating_point` : initial solution (default is a vector of zeros of appropriate dimension)\n\n* `jacobian_residuals` : function that computes the jacobian matrix of the residuals. If not passed as argument, it is computed numericcaly by forward differences\n\n* `eq_constraints` : function that computes the vector of equality constraints\n\n* `jacobian_eqcons` : function that computes the jacobian matrix of the equality constraints. If not passed as argument, it is computed numericcaly by forward differences\n\n* `nb_eqcons` : number of equality constraints\n\n* `ineq_constraints` : function that computes the vector of inequality constraints\n\n* `jacobian_ineqcons` : function that computes the jacobian matrix of the inequality constraints. If not passed as argument, it is computed numericcaly by forward differences\n\n* `nb_ineqcons` : number of inequality constraints\n\n* `x_low` and `x_upp` : respectively vectors of lower and upper bounds\n\n\n\n\n\n","category":"type"},{"location":"api/#Enlsip.CnlsModel-2","page":"API","title":"Enlsip.CnlsModel","text":"CnlsModel\n\nStructure modeling an instance of a constrainted nonlinear least squares problem.\n\n* `residuals` : function that computes the vector of residuals\n\n* `nb_parameters` : number of variables\n\n* `nb_residuals` : number of residuals\n\n* `stating_point` : initial solution\n\n* `jacobian_residuals` : function that computes the jacobian matrix of the residuals\n\n* `eq_constraints` : function that computes the vector of equality constraints\n\n* `jacobian_eqcons` : function that computes the jacobian matrix of the equality constraints\n\n* `nb_eqcons` : number of equality constraints\n\n* `ineq_constraints` : function that computes the vector of inequality constraints\n\n* `jacobian_ineqcons` : function that computes the jacobian matrix of the inequality constraints\n\n* `nb_ineqcons` : number of inequality constraints\n\n* `x_low` and `x_upp` : respectively vectors of lower and upper bounds\n\n* `status_code` : integer indicating the solving status of the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enlsip.objective_value-Tuple{CnlsModel}","page":"API","title":"Enlsip.objective_value","text":"objective_value(model)\n\nOnce the given model has been solved, returns the value of the objective function, i.e. sum of squared residuals functions, computed at the optimal solution. If no convergence, this value is computed at the last solution obtained.\n\nSee also: CnlsModel and solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enlsip.solution-Tuple{CnlsModel}","page":"API","title":"Enlsip.solution","text":"solution(model)\n\nOnce the given model has been solved, this function returns the optimal solution, or last solution obtained if no convergence, as a Vector of approriate dimension.\n\nSee also: solve! and CnlsModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enlsip.solve!-Tuple{CnlsModel}","page":"API","title":"Enlsip.solve!","text":"solve!(model)\n\nOnce a CnlsModel has been instantiated, this function solves the optimzation problem associated by using the method implemented in Enlsip.\n\nThe following optionnal arguments can be provided:\n\nsilent::Bool \nSet to true if one wants the algorithm to print details about the iterations and termination of the solver\nDefault value is set to false\nmax_iter::Int \nMaximum number of iterations allowed\nDefault value is set to 100\nscaling::Bool \nSet to true if one wants the algorithm to work with a constraints jacobian matrix whose rows are scaled (i.e. all constraints gradients vectors are scaled)\nDefault value is set to false\n\n\n\n\n\n","category":"method"},{"location":"api/#Enlsip.status-Tuple{CnlsModel}","page":"API","title":"Enlsip.status","text":"status(model)\n\nReturns readable information on the solving status of model. \n\nSee also:CnlsModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enlsip.total_nb_constraints-Tuple{CnlsModel}","page":"API","title":"Enlsip.total_nb_constraints","text":"total_nb_constraints(model)\n\nReturns the total number of constraints, i.e. equalities, inequalities and bounds, of the given model.\n\nSee also: CnlsModel.\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Enlsip.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Enlsip.jl","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package Enlsip is the Julia version of an eponymous Fortran77 library (ENLSIP standing for Easy Nonlinear Least Squares Inequalities Program) designed to solve nonlinear least squares problems under nonlinear constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The optimization method implemented in Enlsip was conceived in the late 1980s by two swedish authors named Per Lindström and Per Åke Wedin [1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problems that can be solved using Enlsip are modeled as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nmin quad   dfrac12 r(x)^2 \ntextst quad  c_i(x) = 0 quad i =1ldotsq \n c_j(x) geq 0 quad j=q+1ldotsell \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where rmathbbR^nrightarrowmathbbR^m, the residuals, and cmathbbR^nrightarrowmathbbR^q+ell, concatenation of the constraints, are mathcalC^1 multi-functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that box constraints are modeled as general inequality constraints.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To add Enlsip, use Julia's package manager by typing the following command inside the REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Enlsip\")","category":"page"},{"location":"#How-to-use","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Enlsip.jl to solve optimization problems consists in, first, instantiating a model and then call the solver on it. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details and examples with problems from the litterature on the Usage and API pages.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: P. Lindström and P.Å. Wedin, Gauss-Newton based algorithms for constrained nonlinear least squares problems, Institute of Information processing, University of Umeå Sweden, 1988.","category":"page"},{"location":"tutorial/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"This sections provides details on how to instantiate and solve a constrained least squares problem with Enlsip.jl As a reminder from Home, problems to solve are of the following form:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"beginaligned\nmin quad   dfrac12 r(x)^2 \ntextst quad  c_i(x) = 0 quad i =1ldotsq \n c_j(x) geq 0 quad j=q+1ldotsell \nendaligned","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Note that with this formulation, bounds constraints are not distinguished from general inequality constraints. Though, as shown later in this section, they can be provided as vectors of lower and/or upper bounds, which is more convenient for this type of constraints.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Also, the Enlsip solver works with double precision float numbers (i.e. type Float64).","category":"page"},{"location":"tutorial/#Instantiate-a-model","page":"Usage","title":"Instantiate a model","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Solving a problem with Enlsip is organized in two steps.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"First, a model must be created by using the CnlsModel constructor. This constructor requires the evaluation functions of residuals, constraints, their associated jacobian matrices and dimensions of the problem. ","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Although the package enables one to create linear unconstrained least squares, it is recommended to use it to solve nonlinear least squares with general constraints.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"The following three arguments are mandatory to create a model:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"residuals : function that computes the vector of residuals\nnb_parameters : number of variables\nnb_residuals : number of residuals","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"The following keywords arguments are optionnal and deal with constraints and jacobian matrices computations. If the jacobian matrices functions are not provided, they are computed numerically by forward differences within Enlsip.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Argument Details\nstarting_point initial solution (can be an infeasbile point)\njacobian_residuals function computing the jacobian matrix of the residuals\neq_constraints function computing the equality constraints\njacobian_eqcons function computing the jacobian matrix of the equality constraints\nnb_eqcons number of equality constraints\nineq_constraints function computing the inequality constraints\njacobian_ineqcons function computing the jacobian matrix of the inequality constraints\nnb_ineqcons number of inequality constraints\nx_low vector of lower bounds\nx_upp vector of upper bounds","category":"page"},{"location":"tutorial/#Solving-a-model","page":"Usage","title":"Solving a model","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Then, the Enlsip solver can be used by calling the solve! function on a instantiated model. See the API for additionnal information on optionnal arguments that can be passed when calling the solver.","category":"page"},{"location":"tutorial/#Examples","page":"Usage","title":"Examples","text":"","category":"section"},{"location":"tutorial/#Problem-65-from-Hock-and-Schittkowski-collection[1]","page":"Usage","title":"Problem 65 from Hock and Schittkowski collection[1]","text":"","category":"section"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"We show how to implement and solve the following problem:","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"beginaligned\nmin quad  (x_1-x_2)^2 + dfrac(x_1+x_2-10)^29+(x_3-5)^2  \ntextst quad  48-x_1^2-x_2^2-x_3^2 geq 0\n -45leq x_i leq 45 quad i=12\n -5 leq x_3  leq 5\nendaligned","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"First, we provide the dimensions of the problems.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Dimensions of the problem\n\nn = 3 # number of parameters\nm = 3 # number of residuals\nnb_eq = 0 # number of equality constraints\nnb_constraints = 7 # number of inequality constraints","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Then we define the functions required to compute the residuals, constraints, their respective jacobian matrices and a starting point.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Residuals and jacobian matrix associated\nr(x::Vector) = [x[1] - x[2]; (x[1]+x[2]-10.0) / 3.0; x[3]-5.0]\n\njac_r(x::Vector) = [1. -1. 0;\n    1/3 1/3 0.;\n    0. 0. 1.]\n\n# Constraints (one equality and box constraints)\n\nc(x::Vector) = [48.0 - x[1]^2-x[2]^2-x[3]^2] # evaluation function for the equality constraint\njac_c(x::Vector) = [ -2x[1] -2x[2] -2x[3]] # jacobian matrix of the equality constraint\n\nx_l = [-4.5, -4.5, -5.0] # lower bounds\nx_u = [4.5, 4.5, 5.0] # upper bounds\n\n# Starting point \nx0 = [-5.0, 5.0, 0.0]","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"Finally, we can instantiate our model and solve it.","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"# Instantiate a model associated with the problem \nhs65_model = Enlsip.CnlsModel(r, n, m ;starting_point=x0, ineq_constraints = c, nb_ineqcons = 1, x_low=x_l, x_upp=x_u, \njacobian_residuals=jac_r, jacobian_ineqcons=jac_c)\n\n# Call of the `solve` function\nhs65_sol = Enlsip.solve!(hs65_model,silent=true)","category":"page"},{"location":"tutorial/","page":"Usage","title":"Usage","text":"[1]: W. Hock and K. Schittkowski. Test Examples for Nonlinear Programming Codes, volume 187 of Lecture Notes in Economics and Mathematical Systems. Springer, second edition, 1980.","category":"page"}]
}
